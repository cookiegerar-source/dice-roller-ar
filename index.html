<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>Dice Roller AR — Panneau 3D ancré</title>
  <style>html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Arial}#info{position:fixed;left:10px;top:10px;z-index:10;background:rgba(0,0,0,.5);padding:8px;border-radius:6px}button{padding:6px 10px}</style>
</head>
<body>
  <div id="info">1) Appuie sur <strong>Enter AR</strong> → 2) pointe et utilise la gâchette pour placer le panneau → 3) vise des boutons avec le contrôleur et appuie sur la gâchette.</div>
  <canvas id="xr-canvas"></canvas>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    // -- Renderer / Scene / Camera -------------------------------------------------
    const canvas = document.getElementById('xr-canvas');
    const renderer = new THREE.WebGLRenderer({canvas,alpha:true,antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
    scene.add(camera);
    const light = new THREE.HemisphereLight(0xffffff,0xbbbbff,1);
    scene.add(light);

    // -- Reticle for placement ----------------------------------------------------
    let hitTestSource = null, localReferenceSpace = null;
    const reticle = new THREE.Mesh(new THREE.RingGeometry(0.08,0.11,32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color:0x00ffcc}));
    reticle.matrixAutoUpdate = false; reticle.visible = false; scene.add(reticle);

    // -- UI Panel (a group of meshes) ----------------------------------------------
    const panel = new THREE.Group();
    panel.visible = false; // hidden until placed
    scene.add(panel);

    // Canvas used to draw the main UI (results / history)
    const uiCanvas = document.createElement('canvas');
    uiCanvas.width = 1024; uiCanvas.height = 512;
    const uiCtx = uiCanvas.getContext('2d');

    const uiTexture = new THREE.CanvasTexture(uiCanvas);
    uiTexture.minFilter = THREE.LinearFilter;

    const panelGeometry = new THREE.PlaneGeometry(0.8, 0.4);
    const panelMaterial = new THREE.MeshBasicMaterial({map: uiTexture, side: THREE.DoubleSide, toneMapped:false});
    const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
    panelMesh.position.set(0, 0.12, 0);
    panel.add(panelMesh);

    // Decorative frame
    const frameMat = new THREE.MeshStandardMaterial({color:0x222222, metalness:0.3, roughness:0.6});
    const frameGeo = new THREE.BoxGeometry(0.84,0.44,0.02);
    const frame = new THREE.Mesh(frameGeo, frameMat);
    frame.position.set(0,0.12,-0.011);
    panel.add(frame);

    // Interactive buttons as small planes with canvas textures
    function makeButton(label, w, h){
      const c = document.createElement('canvas'); c.width = Math.round(w*200); c.height = Math.round(h*200); const ctx = c.getContext('2d');
      // draw style
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle = '#111'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#fff'; ctx.font = Math.round(c.height*0.45)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label, c.width/2, c.height/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const geo = new THREE.PlaneGeometry(w,h);
      const mat = new THREE.MeshBasicMaterial({map:tex, transparent:false});
      const mesh = new THREE.Mesh(geo, mat); mesh.userData._canvas = c; mesh.userData._ctx = ctx; mesh.userData._tex = tex; mesh.userData._label = label;
      return mesh;
    }

    // Buttons: d-type cycle, count -, count +, add dice, roll, note +/-, clear
    const btnType = makeButton('Type: d6', 0.24, 0.07);
    btnType.position.set(-0.25, -0.08, 0.01); panel.add(btnType);
    const btnCountMinus = makeButton('-', 0.06, 0.06); btnCountMinus.position.set(-0.05,-0.08,0.01); panel.add(btnCountMinus);
    const btnCountLabel = makeButton('x1', 0.08, 0.06); btnCountLabel.position.set(0.05,-0.08,0.01); panel.add(btnCountLabel);
    const btnCountPlus = makeButton('+', 0.06, 0.06); btnCountPlus.position.set(0.17,-0.08,0.01); panel.add(btnCountPlus);

    const btnAdd = makeButton('Ajouter', 0.2, 0.07); btnAdd.position.set(0.42, -0.08, 0.01); panel.add(btnAdd);
    const btnRoll = makeButton('Lancer', 0.3, 0.08); btnRoll.position.set(0.0, 0.18, 0.01); panel.add(btnRoll);

    // Small status plane for showing transient messages (hidden when empty)
    const statusPlane = makeButton('', 0.6, 0.06); statusPlane.position.set(0, -0.18, 0.01); panel.add(statusPlane);

    // State
    let diceTypeOptions = [4,6,8,10,12,20,100];
    let diceTypeIndex = 1; // d6
    let diceCount = 1;
    let queue = []; // array of {type,count}
    let history = [];

    // Update functions for button canvases and main UI
    function updateButtonCanvas(mesh, label){
      const c = mesh.userData._canvas; const ctx = mesh.userData._ctx;
      ctx.clearRect(0,0,c.width,c.height); ctx.fillStyle='#111'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle='#fff'; ctx.font = Math.round(c.height*0.45)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label, c.width/2, c.height/2);
      mesh.userData._tex.needsUpdate = true;
    }

    function updateAllButtons(){ updateButtonCanvas(btnType, 'Type: d' + diceTypeOptions[diceTypeIndex]); updateButtonCanvas(btnCountLabel, 'x' + diceCount); }
    function showStatus(text, t=1500){ const c = statusPlane.userData._canvas; const ctx = statusPlane.userData._ctx; ctx.clearRect(0,0,c.width,c.height); if(text){ ctx.fillStyle='#111'; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='#fff'; ctx.font = Math.round(c.height*0.45)+'px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text, c.width/2, c.height/2); } statusPlane.userData._tex.needsUpdate=true; if(text){ setTimeout(()=>{ ctx.clearRect(0,0,c.width,c.height); statusPlane.userData._tex.needsUpdate=true; }, t); } }

    function renderMainUI(){ // draws on uiCanvas: left = queue + controls, right = history & last roll
      uiCtx.fillStyle = '#0b1020'; uiCtx.fillRect(0,0,uiCanvas.width,uiCanvas.height);
      uiCtx.fillStyle = '#fff'; uiCtx.font = '32px sans-serif'; uiCtx.fillText('Queue', 40, 40);
      uiCtx.font = '28px sans-serif';
      let y = 80;
      if(queue.length===0){ uiCtx.fillStyle='#9aa3b2'; uiCtx.fillText('(vide)', 40, y);} else { uiCtx.fillStyle='#fff'; queue.forEach((q, i)=>{ uiCtx.fillText(`${i+1}) ${q.count}d${q.type}`, 40, y); y+=36; }); }

      // right column
      uiCtx.fillStyle='#fff'; uiCtx.fillText('Historique', uiCanvas.width/2 + 20, 40);
      uiCtx.font = '22px sans-serif'; y = 80;
      if(history.length===0){ uiCtx.fillStyle='#9aa3b2'; uiCtx.fillText('(aucun)', uiCanvas.width/2 + 20, y);} else { uiCtx.fillStyle='#fff'; history.slice(0,6).forEach((h,i)=>{ uiCtx.fillText(`${h.time} — ${h.summary}`, uiCanvas.width/2 + 20, y); y+=30; }); }

      uiTexture.needsUpdate = true;
    }

    updateAllButtons(); renderMainUI();

    // -- Interaction: raycast from controller -------------------------------------
    const controller = renderer.xr.getController(0);
    scene.add(controller);

    const tempMatrix = new THREE.Matrix4();
    const raycaster = new THREE.Raycaster();

    function getIntersections(){
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      const dir = new THREE.Vector3(0,0,-1).applyMatrix4(tempMatrix);
      const origin = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
      raycaster.set(origin, dir);
      const interactive = [btnType, btnCountMinus, btnCountPlus, btnAdd, btnRoll];
      return raycaster.intersectObjects(interactive, false);
    }

    controller.addEventListener('select', ()=>{
      if(!panel.visible) return; // ignore until placed
      const intersects = getIntersections();
      if(intersects.length>0){
        const obj = intersects[0].object;
        if(obj===btnType){ diceTypeIndex = (diceTypeIndex+1) % diceTypeOptions.length; updateAllButtons(); showStatus('Type d' + diceTypeOptions[diceTypeIndex]); }
        else if(obj===btnCountMinus){ diceCount = Math.max(1, diceCount-1); updateAllButtons(); }
        else if(obj===btnCountPlus){ diceCount = Math.min(99, diceCount+1); updateAllButtons(); }
        else if(obj===btnAdd){ queue.push({type: diceTypeOptions[diceTypeIndex], count: diceCount}); renderMainUI(); showStatus('Ajouté: ' + diceCount + 'd' + diceTypeOptions[diceTypeIndex]); }
        else if(obj===btnRoll){ if(queue.length===0){ showStatus('Queue vide'); } else { performRoll(); } }
      }
    });

    // -- Placement: place panel at reticle on controller select when not yet placed ---
    let placed = false;
    controller.addEventListener('selectstart', ()=>{ if(!placed && reticle.visible){ // place panel
        placed = true; panel.visible = true; panel.position.setFromMatrixPosition(reticle.matrix); panel.quaternion.setFromRotationMatrix(reticle.matrix); // offset
        panel.position.y += 0.05; showStatus('Panneau placé');
      }
    });

    // -- Rolling logic -----------------------------------------------------------
    function performRoll(){
      const results = [];
      queue.forEach(item=>{
        let total = 0; const rolls = [];
        for(let i=0;i<item.count;i++){ const v = Math.floor(Math.random()*item.type)+1; rolls.push(v); total+=v; }
        results.push({type:item.type,count:item.count,rolls,total});
      });
      // summarise and add to history
      const totalSum = results.reduce((s,r)=>s+r.total,0);
      const summary = results.map(r=>`${r.count}d${r.type}=${r.total}`).join(' + ');
      const time = new Date().toLocaleTimeString();
      history.unshift({time,summary,total:totalSum}); if(history.length>50) history.pop();

      // update UI canvas with last roll
      uiCtx.fillStyle = '#07202a'; uiCtx.fillRect(0,0,uiCanvas.width,uiCanvas.height);
      uiCtx.fillStyle = '#fff'; uiCtx.font = '36px sans-serif'; uiCtx.fillText('Résultat: ' + totalSum, 40, 50);
      uiCtx.font = '26px monospace'; let y = 100; results.forEach(r=>{ uiCtx.fillText(`${r.count}d${r.type}: [${r.rolls.join(', ')}] => ${r.total}`, 40, y); y+=32; });
      // history right
      uiCtx.fillStyle='#fff'; uiCtx.font='28px sans-serif'; uiCtx.fillText('Historique', uiCanvas.width/2 + 20, 40);
      uiCtx.font='22px sans-serif'; y=80; history.slice(0,6).forEach(h=>{ uiCtx.fillText(`${h.time} ${h.summary} (${h.total})`, uiCanvas.width/2 + 20, y); y+=30; });
      uiTexture.needsUpdate = true;
      queue = []; renderMainUI(); showStatus('Lancé: ' + totalSum, 2000);
    }

    // -- XR frame loop & hit-test setup -----------------------------------------
    renderer.setAnimationLoop(function(timestamp, frame){
      if(frame){
        const session = renderer.xr.getSession();
        if(!hitTestSource){
          session.requestReferenceSpace('viewer').then((ref)=>{
            session.requestHitTestSource({ space: ref }).then(source=>{ hitTestSource = source; });
          });
          session.requestReferenceSpace('local').then((ref)=>{ localReferenceSpace = ref; });
        }
        if(hitTestSource && localReferenceSpace){
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if(hitTestResults.length>0){
            const pose = hitTestResults[0].getPose(localReferenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else { reticle.visible = false; }
        }
      }
      renderer.render(scene, camera);
    });

    // -- Resize handling --------------------------------------------------------
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

    // initial draw
    renderMainUI();

  </script>
</body>
</html>
